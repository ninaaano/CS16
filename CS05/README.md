# CS05

### 학습키워드

- 객체지향 프로그래밍

  모든 데이터를 객체(object)취급하며 이 객체가 바로 프로그래밍의 중심이 된다. 객체(object)란 실생활에서 우리가 인식할 수 있는 사물로 설명할 수 있는데, 이런 객체의 상태(state)와 행동(behavior)을 구체화하는 형태의 프로그래밍이 객체 지향 프로그래밍이다.

- 클래스(class)

  객체를 정의하는 틀 또는 설계도와 같은 의미이다. 클래스는 객체의 상태를 나타내는 필드(field)와 객체의 행동을 나타내는 메소드(method)로 구성 된다. 필드(field)란 클래스에 포함된 변수(variable)를 의미한다. 메소드(method)란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있다.

    ```
    class Car {                    // 클래스 이름
        private String modelName;  // 필드
        private int modelYear;     // 필드
    
        Car(String modelName, int modelYear) { // 생성자
            this.modelName = modelName;
            this.modelYear = modelYear;
        }
     
        public String getModel() { // 메소드
            return this.modelYear + "년식 " + this.modelName + " " + this.color;
        }
    }
    ```
- 객체(object)

  객체란 클래스의 인스턴스나 배열을 말한다. 컴퓨터 공학에서 객체는 변수, 자료 구조, 함수, 메서드, 식별자에 의해 참조된 메모리 상의 값을 의미한다. 객체 지향 프로그래밍에서 객체는 변수, 함수, 자료 구조의 조합이 될 수 있는데, 클래스를 기반으로 한 변수를 클래스의 인스턴스라고 지칭한다.

- 객체 인스턴스(instance)

  인스턴스란 클래스를 바탕으로 실체화되어 메모리에 할당된 실체를 말한다. 클래스에서 나온다는 점에서 객체와 유사하지만 차이점은 객체는 소프트웨어 세계에 구현할 대상이고, 클래스에 따라 소프트웨어 세계에 구현된 실체가 인스턴스이다. 인스턴스는 각자 고유의 특성을 가지고 독립적으로 존재한다. 객체를 소프트 웨어에 실체화 하면 그것을 인스턴스라고 부른다. 인스턴스는 객체에 포함된다.

- 프로퍼티(property)

  클래스 외부에서 필드에 접근할때는 반드시 메소드를 통해여 접근해야하며 이때 get, set으로 시작하는 메소드를 이용한다. 프로퍼티는 객체와 관련하여 이름 붙여진 속성을 말하며 빈이 관리하는 데이터를 의미한다.

  - 프로퍼티 값을 구성하는 메소드는 get으로 시작한다
  - 프로퍼티 값을 변경하는 메소드는 set으로 시작한다
  - get과 set 뒤에는 프로퍼티의 이름 첫 글자를 대문자로 바꾼다
  - set 메소드는 1개의 파라미터를 갖는다

  프로퍼티는 위 같은 규칙을 가지고 있으며 흔테 getter/setter을 묶어서 프로퍼티라고 부른다.

- 메소드(method)

  자바에서 클래스는 멤버(member)로 속성을 표현하는 필드(field)와 기능을 표현하는 메소드(method)를 가진다. 그중에서 메소드(method)란 어떠한 특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있다.

    ```
    접근제어자 반환타입 메소드이름(매개변수목록) { // 선언부
        // 구현부
    }
    ```

  1. 접근 제어자 : 해당 메소드에 접근할 수 있는 범위를 명시
  2. 반환 타입(return type) : 메소드가 모든 작업을 마치고 반환하는 데이터의 타입을 명시
  3. 메소드 이름 : 메소드를 호출하기 위한 이름을 명시
  4. 매개변수 목록(parameters) : 메소드 호출 시에 전달되는 인수의 값을 저장할 변수들을 명시
  5. 구현부 : 메소드의 고유 기능을 수행하는 명령문의 집합

  자바에서는 하나의 클래스에 같은 이름의 메소드를 둘 이상 정의할 수 없다. 하지만 메소드 오버로딩(overloading)을 이용하면, 같은 이름의 메소드를 중복하여 정의할 수 있다. 메소드 오버로딩이란 매개변수의 개수나 타입을 다르게 하여 같은 이름의 또 다른 메소드를 작성하는 것이다. 이러한 메소드 오버로딩을 사용함으로써 메소드에 사용되는 이름을 절약할 수 있다. 또한, 메소드를 호출할 때 전달해야 할 매개변수의 타입이나 개수에 대해 크게 신경을 쓰지 않고 호출할 수 있게 된다.

- 캡슐화(encapsulation)

  캡슐화란 객체의 내부 구조 및 데이터를 캡슐처럼 감싸 외부에서 직접 볼 수 없게 은닉하여 보호하는 것을 말한다. 하지만 객체들끼리 상호작용을 위해서는 일정 부분이 외부에 공개되어야 데이터를 주고받을 수 있다. 이를 위해 클래스와 멤버변수(필드), 메소드는 외부에서 접근 가능한 범위를 지정할 수 있는 접근제어자와 함께 사용된다. 멤버 변수의 경우 보통 private 키워드를 사용하여 외부로부터 직접적인 접근을 막고, getter/setter 라 부르는 메소드를 만들어 사용함으로써 내부 데이터에 제한적 접근을 할 수 있게 된다.

  - getter : 외부에서 변수의 데이터를 읽어올 때 사용되는 메소드
  - setter : 외부에서 변수에 데이터를 쓰고자 할 때 사용되는 메소드

  자바의 접근 제어자

  - public : 접근 제한 없음
  - protected: 동일한 패키지 내에 존재하거나 파생 클래스에서만 접근 가능
  - default : 아무런 접근 제한자를 명시하지 않으면 default 값이 되며, 동일한 패키지 내에서만 접근 가능
  - private: 자기 자신의 클래스 내에서만 접근 가능
- 상속(inheritance)

  상속이란 기존의 클래스에 기능을 추가하거나 재정의 하여 새로운 클래스를 정의하는 것을 의미한다. 상속을 이용하면 기존에 정의되어 있는 클래스의 모든 필드와 메소드를 물려받아 새로운 클래스를 생성할 수 있다. 이때 기존에 정의되어 있던 클래스를 부모 클래스 또는 상위 클래스, 기초 클래스 라고도 한다. 그리고 상속을 통해 새롭게 작성되는 클래스를 자식 클래스, 하위 클래스, 파생 클래스 라고 한다.

  - 상속의 장점
    - 기존에 작성된 클래스를 재활용할 수 있다
    - 자식 클래스 설계 시 중복되는 멤버를 미리 부모 클래스에 작성해놓으면, 자식 클래스에서는 해당 멤버를 작성하지 않아도 된다
    - 클래스 간의 계층적 관계를 구성함으로써 다형성의 문법적 토대를 마련한다.
- 다형성(polymorphism)

  다형성이란 하나의 객체가 여러가지 타입을 가질 수 있는 것을 의미한다. 자바에서는 이러한 다형성을 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 하여 구현한다. 특정 타입의 참조 변수로는 같은 타입의 인스턴스를 참조할 수 있다. 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수와 같기 때문이다. 그리고 부모 클래스 타입의 참조 변수로도 자식 클래스 타입의 인스턴스를 참조할 수 있다. 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 적기 때문이다. 하지만 반대의 경우인 자식 클래스 타입의 참조 변수로는 부모 클래스 타입의 인스턴스를 참조할 수 없다. 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 많기 때문이다.

  [코딩교육 티씨피스쿨](http://www.tcpschool.com/java/java_polymorphism_concept)

- 일반화

  일반화(=제네릭(generic))이란 데이터의 타입(data type)을 일반화한다는 것을 의미한다. 제네릭은 클래스나 메소드에서 사용할 내부 데이터 타입을 컴파일 시 미리 지정하는 방법이다. 이렇게 컴파일 시 미리 타입 검사를 수행하면 다음과 같은 장점을 가진다

  - 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있다.
  - 반환 값에 대한 타입 변환 및 타입 검사에 들어가는 노력을 줄일 수 있다.

    ```java
    class MyArray<T> {
        T element;
        void setElement(T element) { this.element = element; }
        T getElement() { return element; }
    }
    ```

  예제에서 사용된 ‘T’를 타입 변수라고 하며, 임의의 참조형 타입을 의미한다. 꼭 'T'뿐만 아니라 어떠한 문자를 사용해도 상관없으며, 여러 개의 타입 변수는 쉼표(,)로 구분하여 명시할 수 있다. 타입 변수는 클래스에서뿐만 아니라 메소드의 매개변수나 반환값으로도 사용할 수 있다. 위와 같이 선언된 제네릭 클래스를 생성할 때는 타입 변수 자리에 실제 사용할 타입을 명시해야한다.

  **타입 변수의 제한**

  제네릭은 ‘T’와 같은 타입 변수를 사용하여 타입을 제한한다. 이때 extends 키워드를 사용하면 타입 변수에 대한 특정 타입만을 사용하도록 제한할 수 있다.

  **제네릭 메소드**

  제네릭 메소드란 메소드의 선언부에 타입 변수를 사용한 메소드를 의미한다. 이 때 타입변수의 선언은 메소드 선언부에서 반환 타입 바로 앞에 위치한다.

    ```
    public static <T> void sort( ... ) { ... }
    ```

- 객체지향 설계
  - **SRP (Single Responsibility Principle) 단일 책임 원칙**

  클래스의 역할과 책임을 너무 많이 주지 말라는 소리이다. 클래스의 기능을 잘 나눠야 한다. 책임을 적절하게 분배함으로써 코드의 가독성 향상, 유지보수 용이의 이점이 있다. 결합도를 낮추고 응집도를 높이는 것과 관련된 원칙이다.

  - **OCP (Open Closed Principle) 개방 폐쇄 원칙**

  자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀있어야 한다. 이 말은 요구사항의 변경이나 추가사항이 발생하더라고 기존 구성요소는 수정이 일어나지 않아야하며 쉽게 확장이 가능하며 재사용할 수 있어야 한다는 뜻이다. 클래스를 설계할 때 변하는 부분과 변하지 않는 부분을 명확하게 구분해야하고 변할 수 있는 부분은 추상화하여 상속하는 클래스가 의존할 수 있도록 코드를 작성한다.

  - **LSP (Liskov Substitution Principle) 리스코프 치환 원칙**

  하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야한다. 프로그램의 객체는 프로그램의 정확성을 깨트리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야한다. 이는 다형성에서 하위 클래스는 인터페이스 규약을 지켜야 한다는 것을 의미하며 다형성을 지원하기 위한 원칙이다. 예를 들면 박쥐는 포유류의 역할을 할 수 있지만 딸은 아버지의 역할을 할 수 없다.

  - **ISP (Interface Segregation Principle) 인터페이스 분리 원칙**

  상황과 관련 있는 메서드만 제공한다. 이는 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 원칙이다. 하나의 큰 인터페이스를 상속받기 보단 인터페이스를 구체적으로 작은 단위들로 분리시켜 꼭 필요한 인터페이스만 상속하자는 의미이다. ISP는 인터페이스의 단일 책임을 강조한다.

  - **DIP (Dependency Inversion Principle) 의존 역전 원칙**

  자신보다 변하기 쉬운 것에 의존하지 않는다. 하위 클래스나 구체 클래스에 의존하면 안된다는 말이다. 쉽게 말해 구현 클래스에 의존하지 말고 인터페이스에 의존하라는 뜻이다. 구현체제 의존하게 되면 변경이 어려워진다. 인터페이스를 활용하자. 상위클래스 일 수록, 인터페이스일 수록, 추상 클래스 일 수록 변하지 않을 가능성이 크다. 하위클래스나 구체클래스가 아닌 더 추상적에 의존하라는 것이 의존 역전 원칙이다.

  [객체지향 개발 5대 원리: SOLID](https://www.nextree.co.kr/p6960/)

  [[OOP] 객체지향 프로그래밍의 5가지 설계 원칙, 실무 코드로 살펴보는 SOLID](https://mangkyu.tistory.com/194)

- 역할과 책임

  [객체지향) 객체의 역할, 책임, 협력](https://devroach.tistory.com/56)

  [객체 지향의 사실과 오해 - 역할, 책임, 협력](https://imspear.tistory.com/187)

  [[스터디] OOP - 역할과 책임, 협력](https://coffeeandcakeandnewjeong.tistory.com/104)

---

### 객체와 클래스

개발 단계에서는 클래스 단위로 작업하고, 실제로 동작하는 코드는 객체 단위로 동작한다

- 개별 객체의 공통 부분 = 코드는 클래스가 소유한다
- 개별 객체의 고유 부분 = 속성은 인스턴스가 소유한다

---

## 1. 직선 길이

### 학습목표

- 작은 역할을 하는 클래스부터 조금씩 더 복잡한 클래스 만들기
- 객체지향 프로그래밍 패러다임 연습

### 기능요구사항

- 사용자가 점에 대한 좌표 정보를 입력하는 메뉴 구성
- 좌표 정보는 괄호 ( , ) 로 둘러 쌓여 있으면 쉼표로 x와 y값 구분
- 좌표값을 두개 입력한 경우, 두 점을 있는 직선으로 가정. 좌표값과 좌표값 사이는 - 문자로 구분

### 프로그래밍 요구사항

- x,y,좌표 모두 최대 24까지 입력가능
- 입력 범위를 초과할 경우 에러 문구를 출력하고 다시 입력을 받는다
- 입력을 담당하는 별도 모듈 또는 객체를 꼭 선언
- 정상적인 좌표값을 입력한 경우, 해당 좌표에 특수문자 표시
- 직선인 경우는 두 점 사이의 거리를 계산해서 출력

### 힌트

- 두 점 사이 거리는 **`제곱근((A.x - B.x)^제곱 + (A.y - B.y)^제곱)`**
  공식으로 계산할 수 있다.
- 제곱근을 구하는 수학 함수는 sqrt()을 활용한다
- 테스트 코드의 경우 double일 때 근사치를 테스트하는 경우가 많다

### 예상결과 및 동작예시

```
> 좌표를 입력하세요.
(10,10)-(14,15)
```

```
두 점 사이 거리는 6.403124
```

---

## 구현

![스크린샷 2023-01-16 오후 3.44.32.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a2d40f00-618e-4988-bae6-6af00e5b403a/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-01-16_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_3.44.32.png)

> 개인적으로 정말 멋진 코드를 짠다고 생각하는 Albert님의 코드를 공부하다가 public record 라는 클래스가 있는 것을 알게 되었다
record란?
레코드(record)란 “데이터 클래스”이며 순수하게 데이터를 보유하기 위한 특수한 종류의 클래스이다.

[37편. 레코드(Record)](https://blog.hexabrain.net/399)

[[Java] Records](https://jerry92k.tistory.com/16)

  
### 추가 학습

- 자신이 객체를 구현하고, 더 작은 혹은 다른 객체로 나누는 기준은 무엇인가?

---

## 2. 삼각형 넓이

### 학습목표

- 작은 객체를 조합해서 더 큰 객체 설계
- 더 작은 단위나 반복되는 코드가 있다면 일반화해서 별도 클래스 구현

### 기능요구사항

- 좌표값을 세 개 입력한 경우, 세 점을 연결하는 삼각현으로 가정한다
    - 삼각형인 경우 삼각형의 넓이를 계산해서 출력한다
- 세 변의 길이를 알 때 삼각형의 넓이를 구하는 공식은 헤론의 공식을 이용해 구할 수 있다

[헤론의 공식 - 위키백과, 우리 모두의 백과사전](https://ko.wikipedia.org/wiki/%ED%97%A4%EB%A1%A0%EC%9D%98_%EA%B3%B5%EC%8B%9D)

- 내각 sin 값으로도 계산할 수 있다.
    - 삼각형 내각 cos 값을 구하는 공식은 다음과 같다.
    - cos값은 sin값으로 계산할 수 있다.

![http://public.codesquad.kr/jk/triangle-formula.png](http://public.codesquad.kr/jk/triangle-formula.png)

### 프로그래밍 요구사항

- 이전 단계 요구사항 그대로 만족하면서 확장
    - 이전 단계와 동일하게 좌표값 두 개를 입력한 경우, 두 점을 직선으로 가정한다
- 직선과 삼각형 설계에 대해 공통 형식 또는 요소를 찾아낸다
- 직선과 삼각형 객체 역할을 구분해서 구현한다

### 예상결과 및 동작예시

```
좌표를 입력하세요.
(10,10)-(14,15)-(20,8)
```

```
삼각형 넓이는 29.0
```

---

## 3. 사각형 넓이

### 학습목표

- 객체 지향 설계를 위해 다양한 초기화-생성 함수를 구현한다
- 객체지향 다형성을 도입해서 타입을 비교하지 않고 처리할 수 있따

### 기능요구사항

- 좌표값을 네 개 입력한 경우, 네 점을 연결하는 사각형으로 가정한다
    - 네 점이 뒤틀어진 사다리꼴이나 마름모는 제외하고 직사각형만 허용하도록 검사한다
    - 사각형인 경우 사각형의 넓이를 계산해서 출력한다
- 사각형 면적은 **`width * height`**방식으로 계산할 수 있다.
- 모든 객체가 같은 인터페이스를 갖도록 계산과 관련된 메시지를 추상화한다
- 타입별로 출력을 구분하기 위해서 타입을 비교하지말고 상속과 다형성을 활용해서 구현한다

### 프로그래밍 요구사항

- 이전 단계 직선, 삼각형 처리도 그대로 지원하면서 사각형 구현
- 4점을 받는 경우와 width + height를 받는 경우 모두 초기화 생성자를 구현
    - 어느 생성자를 호출해도 동일하게 동작해야 한다
- 데이터를 입력하면 직선, 삼각형, 사각형 구분해서 출력하는 프로그램에서 타입을 구분해서 생성한다
    - 생성한 이후에는 직선, 삼각형, 사각형 모두 동일한 인터페이스(함수 이름과 매개변수)를 가지도록 하고 같은 이름으로 호출해야 한다
    - 예를 들어 출력하는 메소드가 모두 동일해야 한다

```
좌표를 입력하세요.
(10,10)-(22,10)-(22,18)-(10,18)
```

```
사각형 넓이는 96
```

---

## 4. 다각형 넓이

### 학습 목표

- 객체지향 설계를 위해 다양한 초기화-생성 함수를 구현한다
- 객체지향 다형성을 도입해서 타입을 비교하지 않고 처리할 수 있다
- 객체마다 역할과 책임을 설명할 수 있다

### 기능요구사항

- 좌표값을 5개 이상 입력한 경우, 다각형으로 가정한다
    - 다각형인 경우 기준점을 정해서 삼각형으로 나눠서 처리하고, 삼각형 타입을 활용해서 다각형 넓이를 계산한다

![https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/1640575888901Screen%20Shot%202021-12-27%20at%2012.31.10%20PM.png](https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/1640575888901Screen%20Shot%202021-12-27%20at%2012.31.10%20PM.png)

### 프로그래밍 요구사항

- 이전 단계를 그대로 지원하면서 다각형을 구현해야 한다
- 5점개 이상을 처리할 수 있도록 생성자를 구현한다
    - 만약 4개 이하를 입력할 경우는 예외(exception)으로 한다
- 데이터를 입력하면 다각형 점을 출력하는 프로그램에서 타입을 구분해서 생성한다
    - 이전에 생성한 직선, 삼각형, 사각형 타입까지 모두 동일한 인터페이스(함수 이름과 매개변수)를 가지도록 하고 같은 이름으로 호출해야 한다
    - 예를 들어 출력하는 메소드가 모두 동일해야 한다
- 다형성에 맞는 객체를 생성하는 팩토리 객체를 구현한다
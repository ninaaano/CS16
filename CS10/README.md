# CS10

# 프로세스 스케줄링 시각화

### 스케줄링

스케줄링은 여러 프로세스가 번갈아가며 사용하는자원을 어떤 시점에 어떤 프로세스에게 자원을 할당할 지 결정하는 것이다. 좋은 스케줄링은 프로세스의 효율성을 높이고 프로세스의 응답시간을 최소화 하여 시스템의 작업 처리 능력을 향상시킨다. 즉 , Cpu가 쉬지않고 계속해서 돌 수 있도록 해준다

- 결정 시점
1. 수행 → 대기
2. 수행 → 준비
3. 대기 → 준비
4. 수행 → 종료
- 비선점형 스케줄링(Non-preemptive Scheduling) : 어떤 프로세스가 CPU를 할당 받으면 그 프로세스가 종료되거나 입출력 요구가 발생하여 자발적으로 중지될 때까지 계속 실행되도록 보장한다. 순서대로 처리되는 공정성이 있고 다음에 처리해야 할 프로세스와 관계없이 응답 시간을 예상할 수 있으며 선점 방식보다 스케줄러 호출 빈도가 낮고 [문맥 교환](https://ko.wikipedia.org/wiki/%EB%AC%B8%EB%A7%A5_%EA%B5%90%ED%99%98)에 의한 [오버헤드](https://ko.wikipedia.org/wiki/%EC%98%A4%EB%B2%84%ED%97%A4%EB%93%9C)가 적다. [일괄 처리](https://ko.wikipedia.org/wiki/%EC%9D%BC%EA%B4%84_%EC%B2%98%EB%A6%AC) 시스템에 적합하며, CPU 사용 시간이 긴 하나의 프로세스가 CPU 사용 시간이 짧은 여러 프로세스를 오랫동안 대기시킬 수 있으므로, 처리율이 떨어질 수 있다는 단점이 있다.
- 선점형 스케줄링(Preemptive Scheduling) : 어떤 프로세스가 CPU를 할당받아 실행 중에 있어도 다른 프로세스가 실행 중인 프로세스를 중지하고 CPU를 강제로 점유할 수 있다. 모든 프로세스에게 CPU 사용 시간을 동일하게 부여할 수 있다. 빠른 응답시간을 요하는 대화식 시분할 시스템에 적합하며 긴급한 프로세서를 제어할 수 있다. '운영 체제가 프로세서 자원을 선점'하고 있다가 각 프로세스의 요청이 있을 때 특정 요건들을 기준으로 자원을 배분하는 방식이다.
- 비선점 프로세스 스케줄링
1. [FCFS 스케줄링](https://ko.wikipedia.org/wiki/FCFS_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)(First Come First Served Scheduling)
2. [SJF 스케줄링](https://ko.wikipedia.org/wiki/SJF_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)(Shortest Job First Scheduling)
3. [HRRN 스케줄링](https://ko.wikipedia.org/wiki/HRRN_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)(Highest Response Ratio Next Scheduling)
- 선점 프로세스 스케줄링
1. [RR 스케줄링](https://ko.wikipedia.org/wiki/RR_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)(Round Robin Scheduling)
2. [SRTF 스케줄링](https://ko.wikipedia.org/wiki/SRTF_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)(Shortest Remaining-Time First Scheduling)
3. [다단계 큐 스케줄링](https://ko.wikipedia.org/wiki/%EB%8B%A4%EB%8B%A8%EA%B3%84_%ED%81%90_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)(Multilevel Queue Scheduling)
4. [다단계 피드백 큐 스케줄링](https://ko.wikipedia.org/wiki/%EB%8B%A4%EB%8B%A8%EA%B3%84_%ED%94%BC%EB%93%9C%EB%B0%B1_%ED%81%90_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)(Multilevel Feedback Queue Scheduling)
5. [RM 스케줄링](https://ko.wikipedia.org/wiki/RM_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)(Rate Monotonic Scheduling)
6. [EDF 스케줄링](https://ko.wikipedia.org/wiki/EDF_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81)(Earliest Deadline First Scheduling)

### 프로세스

프로세스란 실행 중인 프로그램이다. 프로그램은 보조 기억장치(하드디스크,SSD)에 존재하며 실행되기를 기다리는 명령어(코드)와 정적인 데이터의 묶음이다. 이 프로그램의 명령어와 정적 데이터가 메모리에 적재되면 프로세스가 된다.

### PCB

프로세스 제어 블록(PCB, Process Control Block)이라고 부르며, 프로세스에 대한 정보를 가지고 있다.

- PID

  운영체제가 각 프로세스를 식별하기 위해 부여된 프로세스 식별 번호

- 프로세스 상태
  CPU는 프로세스를 빠르게 교체하면서 실행하기 때문에 실행 중인 프로세스도 있고 대기 중인 프로세스도 있다. 그런 프로세스의 상태를 저장한다
- 프로그램 카운터
  CPU가 다음으로 실행할 명령어를 가리키는 값. CPU는 기계어를 한 단위씩 읽어서 처리하는데 프로세스를 실행하기 위해 다음으로 실행할 기계어가 저장된 메모리 주소를 가리키는 값
- 스케줄링 우선순위
  운영체제는 여러개의 프로세스를 동시에 실행하는 환상을 제공한다. 운영체제가 여러 개의 프로세스가 CPU에서 실행되는 순서를 결정하는 것을 스케줄링 이라고 한다. 이 스케줄링에서 우선순위가 높으면 먼저 실행될 수 있는데 이를 스케줄링 우선순위라고 한다.
- 권한
  프로세스가 접근할 수 있는 자원을 결정하는 정보.
- 프로세스의 부모의 자식 프로세스
  최초로 생성되는 int 프로세스를 제외하고 모든 프로세스는 부모 프로세스를 복제해서 생성되고 이 계층관계는 트리를 형성한다. 그래서 각 프로세스는 자식 프로세스와 부모 프로세스에 대한 정보를 가지고 있다
- 프로세스의 데이터와 명령어가 있는 메모리 위치를 가리키는 포인터
  프로세스는 실행중인 프로그램이다. 따라서 프로그램에 대한 정보를 가지고 있어야 한다. 프로그램에 대한 정보는 프로세스가 메모리에 가지는 자신만의 주소 공간에 저장된다. 이 공간에 대한 포인터 값을 가진다
- 프로세스에 할당된 자원들을 가리키는 포인터
- 실행 문맥
  프로세스가 실행 상태에서 마지막으로 실행한 프로세서의 레지스터 내용을 담고있다. CPU에 의해 실행되는 프로세스는 운영체제에 의해 계속 교체되는데 교체되었다가 다시 자신의 차례가 되어서 실행 될 때 중단된 적 없고 마침 연속적으로 실행된 것처럼 하기 위해 이 레지스터 정보를 가지고 있다.

### 운영체제

운영체제는 컴퓨터 시스템의 자원들을 효율적으로 관리하며, 사용자가 컴퓨터를 편리하고, 효과적으로 사용할 수 있도록 환경을 제공하는 여러 프로그램의 모임이다. 운영체제는 컴퓨터 사용자와 컴퓨터 하드웨어 간의 인터페이스로서 동작하는 시스템 소프트웨어의 일종으로, 다른 응용프로그램이 유용한 작업을 할 수 있도록 환경을 제공한다. 대표적인 컴퓨터 운영체제로는 윈도루, 맥 OS, 리눅스, 유닉스 등이 있다.

### 운영체제의 기능

- 프로세서, 기억장치, 입출력 장치, 파일 및 정보등의 자원을 관리
- 자원을 효율적으로 관리하기 위래 자원의 스케줄링 기능 ㅈ[공
- 사용자와 시스템 간의 편리한 인터페이스 제공
- 시스템의 각종 하드웨어와 네트워크를 관리 및 제어
- 데이터를 관리하고 데이터 및 자원의 공유 기능 제공
- 시스템의 오류를 검사 및 복구
- 자원 보호 기능 제공
- 입출력 보조 기능 제공

### 운영체제의 목적

운영체제의 목적에는 처리능력 향상, 반환 시간 단축, 사용 가능도 향상, 신뢰도 향상 등이 있다. 처리 능력, 반환 시간, 사용 가능도, 신뢰도는 운영체제의 성능을 평가하는 기준이 된다.

- 처리능력 : 일정 시간 내에 시스템이 처리하는 일의 양
- 반환 시간 :  시스템에 작업을 의뢰한 시간부터 처리가 완료될 때까지 건린 시간
- 사용가능도 : 시스템을 사용할 필요가 있을 때 즉시 사용 가능한 정도
- 신뢰도 : 시스템이 주어진 문제를 정확하게 해결하는 정도

### 우선순위 스케줄링

준비 큐에 프로세스가 도착하면, 도착한 프로세스의 우선순위와 현재 실행중인 프로세스의 우선순위를 비교하여 우선순위가 가장 높은 프로세스에 프로세서를 할당하는 방식

### 라운드로빈 스케줄링

**라운드 로빈 스케줄링**(Round Robin Scheduling, RR)은 시분할 시스템을 위해 설계된 선점형 스케줄링의 하나로서, 프로세스들 사이에 우선순위를 두지 않고, 순서대로 시간단위(Time Quantum)로 CPU를 할당하는 방식의 [CPU 스케줄링](https://ko.wikipedia.org/wiki/CPU_%EC%8A%A4%EC%BC%80%EC%A4%84%EB%A7%81) [알고리즘](https://ko.wikipedia.org/wiki/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)이다.

보통 시간 단위는 10 ms ~ 100 ms 정도이다. 시간 단위동안 수행한 프로세스는 준비 큐의 끝으로 밀려나게 된다. 문맥 전환의 오버헤드가 큰 반면, [응답시간](https://ko.wikipedia.org/wiki/%EC%9D%91%EB%8B%B5%EC%8B%9C%EA%B0%84)이 짧아지는 장점이 있어 [실시간 시스템](https://ko.wikipedia.org/wiki/%EC%8B%A4%EC%8B%9C%EA%B0%84_%EC%8B%9C%EC%8A%A4%ED%85%9C)에 유리하다.

프로세스 스케줄링 방식

---

### 기능요구사항

- 프로세스를 일정한 시간동안 실행하는 프로그램 구현
- 프로세스 종류는 A부터 F까지 6개. 최대 동작시간 겹치지 않는다
- 운영체제는 한번에 프로세스 하나씩만 1초동안 실행
- 1초 이후 같은 프로세스가 아니라 다른 프로세스 실행. 프로세스가 1개만 남은 경우 반복해서 같은 프로세스 실행
- 관리할 프로세스 상태는 준비ready, 실행running, 대기waiting, 종료terminated 4 가지 상태 중에 하나

### 프로그래밍 요구사항

- 프로그램 시작 시 랜덤으로 프로세스 3개 생성하고 대기 큐에 추가
    - 준비, 대기상태에서만 실행 가능
    - 누적 동작 시간이 최대 동작 시간만큼 실행한 프로세스는 종료 상태로 바뀐다
    - 누적 동작시간이 최대 동작시간보다 작으면, 대기 상태로 바꿨다가 준비상태로 변경
        - 대기 상태는 입출력 대기나 다른 응답을 위해 사용하지만, 입출력을 다루지 않기 때문에 준비 상태로 바로 바꾸지 않고 대기 → 준비로 변경
- 프로세스마다 작업 정보를 포함하는 데이터 구조 또는 타입 선언
    - 프로세스 타입을 선언하고 프로세스마다 1초씩 동작하는 구조를 구현
- 프로그램은 1초마다 전체 프로세스 상태와 대기 시간과 누적 실행 시간을 표시
- 프로그램은 모든 프로세스가 종료 상태가 되면 종료하다
- 라운드 로빈으로 구현해보자


### 구현할 기능

- [ ] 실행시간은 주어진 시간까지만 증가한다
- [ ] 상태는 변경 가능하다
- [ ] 대기시간은 본인 차례때는 증가하지 않고 다른 차례때만 증가한다
- [ ] 평균 대기 시간 계산
  - 총 대기 시간 계산 후 평균 내기
- [ ] 평균 반환 시간
  - 실행 시간 + 대기 시간
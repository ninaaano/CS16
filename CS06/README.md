# CS06

### 학습키워드

- 일급 객체(First-class citizen)

  함수형 프로그래밍에서 많이 언급된다. 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는객체
    1. 변수나 데이터에 할당할 수 있어야 한다(=담을 수 있어야한다)
    2. 객체의 인자(파라미터)로 넘길 수 있어야 한다
    3. 객체의 리턴값으로 리턴 할 수 있어야 한다(=사용할 수 있어야한다)
       Java에서는 위의 조건에 해당되지 않지만, lamda는 메서드가 1개만 존재하는 인터페이스/클래스를 통해 마치 함수를 전달하는 것처럼 여겨혀 함수를 1급 객체로 취급하지 않는 java의 단점을 어느정도 해결한 것이라 볼 수 있다

  자바의 메소드는 변수에 할당할 수 없고 베소드를 메소드 입력값으로 보내는 행위는 불가능하다. 자바의 메소드는 리턴값으로 메소드 자체를 반환하는 행위는 불가능하다. 이런 관점에서 람다식 혹은 익명클래스는 변수나 매개 변수에 할당할수 있고 리턴값으로도 사용할 수 있기 때문에 일급 객체의 요건을 충족한다

    1. 변수나 데이터에 담을 수 있어야한다

    ```
    import java.util.function.Consumer;
    
    public class Main {
        public static void main(String[] args) {
            Consumer<String> c = (t) -> System.out.println(t); // 람다식을 인터페이스 타입 변수에 할당
            c.accept("Hello World");
        }
    }
    ```

    2. 함수의 파라미터로 전달 할 수 있어야 한다

    ```
    import java.util.function.Consumer;
    
    public class Main {
        // 메소드 매개변수로 람다 함수를 전달
        public static void print(Consumer<String> c, String str) {
            c.accept(str);
        }
    
        public static void main(String[] args) {
            print((t) -> System.out.println(t) ,"Hello World");
        }
    }
    ```

  3. 함수의 리턴값으로 사용할 수 있어야 한다

    ```
    public class Main {
    
        public static Object hello(){
            System.out.println("Hello World");
            return new Object() { // 익명 클래스 객체를 리턴값으로
                public String toString() {
                    return "Hello World 22";
                }
            };
        }
    
        public static void main(String[] args) {
            Object obj = hello();
            System.out.println(obj.toString());
        }
    }
    ```

- 일급 컬렉션(First Class Collection)

  Collection을 Wrapping하면서, 그 외 다른 멤버 변수가 없는 상태를 일급 컬렉션이라 한다. Wrapping함으로써 가지는 이점은 다음과 같다

    1. 비즈니스에 종속적인 자료구조
    2. Collection의 불변성 보장
    3. 상태와 행위를 한 곳에서 정리
    4. 이름이 있는 컬렉션

  [일급 컬렉션 (First Class Collection)의 소개와 써야할 이유](https://jojoldu.tistory.com/412)

  [[객체지향 생활체조 원칙] 규칙 8. 일급 컬렉션을 쓴다](https://limdingdong.tistory.com/14)

- 다형성

  다형성(polymorphism)이란 하나의 객체가 여러 가지 타입을 가질 수 있는 것을 의미한다. 자바에서는 이러한 다형성을 부모 클래스 타입의 참조 변수로 자식 클래스 타입의 인스턴스를 참조할 수 있도록 하여 구현하고 있다. 다형성은 상속, 추상화와 더불어 객체 지향 프로그랭밍을 구성하는 중요한 특징 중 하나이다.

  **참조 변수의 다형성**

  자바에서는 다형성을 위해 부모 클래스 타입의 참조 변수로서 자식 클래스 타입의 인스턴스를 참조할 수 있도록 하고 있다. 이 때 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 같거나 적어야 참조할 수 있다.

    ```
    class Parent { ... }
    class Child extends Parent { ... }
    ...
    Parent pa = new Parent(); // 허용
    Child ch = new Child();   // 허용
    Parent pc = new Child();  // 허용
    Child cp = new Parent();  // 오류 발생.
    ```

  특정 타입의 참조 변수로는 당연히 같은 타입의 인스턴스를 참조할 수 있다. 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수와 같기 때문이다.

  그리고 부모 클래스 타입의 참조 변수로도 자식 클래스 타입의 인스턴스를 참조할 수 있다. 참조변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 적기 때문이다.

  하지만 반대인 경우 자식 클래스 타입의 참조 변수로는 부모 클래스 타입의 인스턴스를 참조할 수 없다. 참조 변수가 사용할 수 있는 멤버의 개수가 실제 인스턴스의 멤버 개수보다 많기 때문이다.

  **참조 변수의 타입 변환**

  참조 변수도 다음과 같은 조건에 따라 타입 변환을 할 수 있다.

    1. 서로 상속 관계에 있는 클래스 사이에만 타입 변환을 할 수 있다
    2. 자식 클래스 타입에서 부모 클래스 타입으로의 타입 변환은 생략 할 수있다
    3. 하지만 부모 클래스 타입에서 자식 클래스 타입으로의 타입 변환은 반드시 명시해야 한다

  참조 변수의 타입 변환도 기본 타입의 타입 변환과 마찬가지로 타입 캐스트 연산자를 사용한다

    ```
    (변환할타입의클래스이름) 변환할참조변수
    ```

    ```
    class Parent { ... }
    class Child extends Parent { ... }
    class Brother extends Parent { ... }
    ...
    Parent pa01 = null;
    Child ch = new Child();
    Parent pa02 = new Parent();
    Brother br = null;
     
    pa01 = ch;          // pa01 = (Parent)ch; 와 같으며, 타입 변환을 생략할 수 있음.
    br = (Brother)pa02; // 타입 변환을 생략할 수 없음.
    br = (Brother)ch;   // 직접적인 상속 관계가 아니므로, 오류 발생.
    ```

- 추상화

  추상화는 구체적인 사물들간의 공통점을 취하고 차이점을 버리는 일반화를 사용하거나, 중요한 부분을 강조하기 위해 불필요한 세부 사항을 제거함으로써 단순하게 만든다. 핵심은 불필요한 코드를 제거하고 중요한 부분을 살리는 것이다

    ```
    public class SuperCar {
    
        public void move() {
            System.out.println("슈퍼하게 달립니다.");
        }
    }
    
    public class SnowCar {
    
        public void move() {
            System.out.println("겨울에 잘 달립니다.");
        }
    }
    
    public class FastCar {
    
        public void move() {
            System.out.println("빠르게 달립니다.");
        }
    }
    ```

    ```
    public class Main {
    
        public static void main(String[] args) {
            final SuperCar superCar = new SuperCar();
            final SnowCar snowCar = new SnowCar();
            final FastCar fastCar = new FastCar();
    
            superCar.move();
            snowCar.move();
            fastCar.move();
        }
    }
    ```

  움직인다는 행위는 같으므로 차의 공통된 속성인 move를 상위클래스로 만들 수 있다. 똑같은 자동차들이므로 Car라는 상위 클래스를 두어 상속관계로 만들어도 무방하다. 캡슐화를 지키기 위해 추상클래스로 변경해보면

    ```
    public abstract class Car {
    
        public abstract void move();
    }
    
    public class FastCar extends Car{
    
        @Override
        public void move() {
            System.out.println("빠르게 달립니다.");
        }
    }
    
    public class SnowCar extends Car {
    
        @Override
        public void move() {
            System.out.println("겨울에 잘 달립니다.");
        }
    }
    
    public class SuperCar extends Car {
    
        @Override
        public void move() {
            System.out.println("슈퍼하게 달립니다.");
        }
    }
    ```

  하위 클래스들은 추상 메소드로 재정의한다

    ```
    public class Main {
    
        public static void main(String[] args) {
            final List<Car> cars = Arrays.asList(new SuperCar(), new SnowCar(), new FastCar());
            for (final Car car : cars) {
                car.move();
            }
        }
    }
    ```

- 인터페이스

  자식 클래스가 여러 부모 클래스를 상속받을 수 있다면, 다양한 동작을 수행할 수 있다는 장점을 가진다. 하지만 클래스를 이용하여 다중 상속을 할 경우 메소드 출처의 모호성 등 여러가지 문제가 발생할 수 있어 자바에서는 클래스를 통한 다중 상속은 지원하지 않는다. 하지만 다중 상속의 이점을 얻기위해 자바에서는 인터페이스로 다중 상속을 지원하고 있다.

  인터페이스란 다른 클래스를 작성할 때 기본이 되는 틀을 제공하면서, 다른 클래스 사이의 중간 매개 역할까지 담당하는 일종의 추상 클래스를 의미한다. 자바에서 추상 클래스는 추상 메소드뿐만 아니라 생성자, 필드, 일반 메소드도 포함할 수 있다.

  하지만 인터페이스는 오로지 추상 메소드와 상수만을 포함할 수 있다

  **인터페이스의 선언**

  자바에서 인터페이스를 선언하는 방법은 클래스를 작성하는 방법과 같다. 인터페이스를 선언할 때에는 접근 제어자와 함께 interface 키워드를 사용하면 된다.

    ```
    접근제어자 interface 인터페이스이름 {
        public static final 타입 상수이름 = 값;
        ...
        public abstract 메소드이름(매개변수목록);
        ...
    }
    ```

  단 클래스와는 달리 인터페이스의 모든 필드는 public static final 이어야 하며, 모든 메소드는 public abstract이어야 한다. 이 부분은 모든 인터페이스에 공통으로 적용되는 부분이므로 이 제어자는 생략할 수 있다. 이렇게 생략된 제어자는 컴파일 시 자바 컴파일러가 자동으로 추가해준다

  **인터페이스의 구현**

  인터페이스는 추상 클래스와 마찬가지로 자신이 직접 인스턴스를 생성할 수 없다. 따라서 인터페이스가 포함하고 있는 추상 메소드를 구현해줄 메소드를 작성해야 한다.

    ```
    class 클래스이름 implements 인터페이스이름 { ... }
    ```

  만약 모든 추상 메소드를 구현하지 않는다면, abstract 키워드를 사용하여 추상클래스를 선언해야 한다.

  클래스를 이용하여 다중상속을 하면 메소드 출처의 모호성 등의 문제가 발생할 수 있다. 하지만 인터페이스를 이용하여 다중 상속을 하게되면, 같은 메소드 호출의 모호성을 방지할 수 있다.

  **인터페이스의 장점**

  인터페이스를 사용하면 다중 상속이 가능할 뿐만 아니라 다음과 같은 장점을 가질 수 있다

    1. 대규모 프로젝트 개발 시 일관되고 정형화된 개발을 위한 표준화가 가능하다
    2. 클래스의 작성과 인터페이스의 구현을 동시에 진행할 수 있으므로, 개발 시간을 단축할 수 있다
    3. 클래스와 클래스 간의 관계를 인터페이스로 연결하면, 클래스마다 독립적인 프로그래밍이 가능하다
- 캡슐화

  객체, 즉 클래스의 내부 변수와 메소드를 하나로 패키징하는 특징이다. 캡슐화와 비슷한 개념으로는 정보 은닉이 있는데 정보 은닉은 객체의 내부 구현을 숨김으로써 객체사 반드시 정해진 메소드를 통해 상호작용하도록 유도한다.

  이 두 개념은 객체의 응집도와 독립성을 높임으로써 객체의 모듈화를 지향한다. 객체의 모듈화가 잘 이루어져 있을 경우 모듈 단위의 재사용이 매우 용이하다. 여러 로직에서 중복되는 코드를 모듈로 대체하면 모듈 내부의 소스만 수정하는 것으로 수정사항을 반영할 수 있다. 이는 곧 간편한 유지보수와 직결된다

    - `public`: 다른 객체에서 해당 객체의 인스턴스를 생성하여 접근할 수 있다.

  반드시 외부의 접근이 필요한 멤버 변수나 메소드에만 사용해야 한다. 해당 접근 제어자를 남용할 경우 불필요한 요소를 개방하게되어 정보 은닉이 이루어지지 않는다.

    - `protected`: 해당 객체를 상속받은 객체 내부에서 접근할 수 있다. 단순 인스턴스에선 접근할 수 없다.

  protected는 상속과 연관된 접근제어다가. 이 제어자를 가진 요소는 해당 객체를 상속받은 객체만 접근할 수 있다. public 과 달리 별도의 인스턴스는 받지 않아도 된다. 부모 객체의 멤버 변수와 메소드의 접근 권한을 일부 승계받기 때문이다.

    - `default`: 동일한 패키지 내의 객체에서 인스턴스를 생성하여 접근할 수 있다.

  default는 제한적인 public 접근 제어자라 할 수 있다. 이 제어자를 가진 요소는 동일한 패키지 내에서만 접근할 수 있다. 패키지가 같을 경우 public, 패키지가 다를 경우 private과 같은 동작을 한다. 동일한 패키지 여부에 따라 개방/폐쇄가 갈린다. 만약 변수나 메소드에 별다른 접근제어자를 지정하지 않았다면 이 제어자가 기본으로 적용된다.

    - `private`: 선언된 객체 내부에서만 사용 가능하며, 외부에선 어떠한 방법으로든 해당 지시자를 가진 변수 혹은 메소드를 사용할 수 없다.

  private은 반드시 선언된 객체 내부에서만 접근할 수 있다. 메소드 뿐만 아니라 멤버 변수도 마찬가지다. 은닉화를 위한 접근제어자로, 해당 접근제어자의 사용을 통해 내부 변수나 메소드를 은닉할 수 있다.

  객체는 기본적으로 은닉화가 이루어져야한다. 객체를 구현할 때 개방/폐쇄의 명세를 디테일하게 명세하지 않았다면 일단은 private로 만드는 것이 좋다. 이후 설계 과정에서 적절한 개방이 필요할 경우 해당 메소드나 변수를 개방한다. 이와 같은 방식은 필요 시에 요소를 적절히 개방함으로써, 차후 불필요한 개방을 미연에 방지할 수 있다. 올바른 캡슐화/은닉화를 구현하는데 용이한 방식이다.

  모든 메소드를 개방시킨 객체는 모듈이라 보기 어렵다. 반대로 모든 메소드를 은폐시킨 객체 역시 모듈로써의 의마가 전혀 없다. 즉 객체가 모듈의 의미를 갖기 위해선 적절히 설계된 개방/폐쇄가 필요하다. 캡슐화와 정보은닉은 메소드가 모듈로써 의미를 갖게해주는 중요한 요소이다

  대표적인 접근제어자는 위와 같으며, 이를 통해 객체 내부의 상태와 동작의 접근 방법을 강제할 수 있다.

  [[OOP] 객체지향의 특징 - 캡슐화(Encapsulation)와 정보 은닉 - 𝝅번째 알파카의 개발 낙서장](https://blog.itcode.dev/posts/2021/08/08/encapulation)

- 모듈

  모듈이란 프로그램을 구성하는 구성 요소로, 관련된 데이터와 함수를 하나로 묶은 단위를 의미한다. 보통 하나의 소스 파일에 모든 함수를 작성하지 않고, 함수의 기능 별로 따로 모듈을 구성한다. 이러한 모듈을 합쳐 하나의 파일로 작성하는 방식으로 프로그램을 만들게 된다. 프로그램 코드를 기능별로 나눠서 독립된 파일에 저장하여 관리하는 방식을 모듈화 프로그래밍 이라고 한다.

- 메타 타입

  자바에서는 메타 타입이 메타데이터로 불리는 것 같다. 메타데이터란 애플리케이션이 처리해야할 데이터가 아니라, 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지 알려주는 정보이다. 직접 정의해서 사용할 일은 크게 없지만 스프링 프레임워크를 사용한다면 자주 사용하게 되므로 공부하는 것이 좋아

  어노테이션 = 메타데이터

    1. 컴파일러에게 코드 문법 에러를 체크하도록 정보를 제공
    2. 소프트웨어 개발 툴이 빌드나 배치 시 코드를 자동으로 생성할 수 있도록 정보를 제공
    3. 실행 시(런타임 시) 특정 기능을 실행하도록 정보를 제공

  메타 타입은 스위프트에서 많이 사용되는 개념같은데 알아두면 나중에 사용할 일이 생길까?

  [[Swift] Metatype 이란?](https://woozzang.tistory.com/160)


### 학습 목표

- 객체지향 패러다임 연습하기
- 클래스 역할 분리
- 반복되는 코드 별도 클래스 구현

## 객체지향 프로그래밍

### 인스턴스와 참조 instance reference

인스턴스를 참조하는 포인터 변수를 통해 객체에 접근

![http://public.codesquad.kr/jk/Objects/pointer-indirection.png](http://public.codesquad.kr/jk/Objects/pointer-indirection.png)

**프로세스 메모리와 객체 인스턴스 관계**

포인터 변수는 스택에 생기고, 인스턴스는 힙 영역에 생긴다

![https://lucas-image.codesquad.kr/1670913540767instance-in-heap.png](https://lucas-image.codesquad.kr/1670913540767instance-in-heap.png)

### **객체 개별성 Identity 와 동등성 Equality**

위의 pen 예제에서

- myPen과 yourPen은 서로 다른 메모리에 위치하는 개별적인 인스턴스라서 개별성 Identity이 다르다.
- myPen과 yourPen 인스턴스 개별성은 다르지만, 우연히 속성이 모두 같으면 동등한 값을 가지기 때문에 동등성Equality은 같다.
- 개별성과 동질성은 객체 인스턴스를 비교하는 기준이 된다.
- 프로그래밍 언어마다 개별성과 동질성을 구분하며, 다르게 비교하는 비교 연산자를 제공하기도 한다.

### **역할과 책임 Role & Responsibility**

객체의 역할과 책임은 인스턴스에 있는 데이터 값과 클래스에 있는 행위 구현을 모두 의미한다. 같은 클래스에서 생성한 인스턴스는 동일한 클래스 구현체를 참조한다.

# **객체지향 설계**

**`객체를 설계한다`**는 의미는 구현을 하기 전에 만들기를 시도한다는 것이다. 그렇지만 설계는 설계만으로 완벽할 수 없다. 설계를 하고 흐름을 점검할 수는 있지만, 어떻게 구현할 지 판단할 수는 있지만 구현을 해서 설계대로 동작하는 지 점검해야 한다. 설계와 개발, 그리고 테스트는 절대 떨어질 수 없는 관계이다.동일한 설계를 공유하기 위한 표현하기 위한 방법부터 살펴보자.

### **UML 통합 모델링 언어**

[http://www.w3ii.com/ko/uml/uml_basic_notations.html](http://www.w3ii.com/ko/uml/uml_basic_notations.html)

모든 UML 다이어그램을 외울 필요는 없지만, 다른 개발자가 UML로 설계한 그림을 보고 판단할 수 있어야 하고 스스로도 다른 개발자에게 UML로 설계를 설명할 수 있어야 한다.

### **구조를 표현하는 다이어그램:**

- Class diagram
- Object diagram
- Component diagram
- Deployment diagram

### **동작을 표현하는 다이어그램:**

- Use Case diagram
- Sequence diagram
- Communication diagram (예전 Collaboration)
- State-chart diagram
- Activity diagram

### **모델 관리를 나타내는 다이어그램:**

- Package diagram
- Model diagram
- Subsystem diagram

### **타입Type 이란?**

- 타입은 값들의 집합(카테고리)
- **`Int`** : 정수형 값들의 집합
- **`Float`**: 실수형 값들의 집합
- **`Bool`**: { true, false } 집합
- **`String`** : 모든 문자열의 집합
- **`Array<Int>`** 또는 **`List<Int>`** : 모든 정수형 값 목록에 대한 집합
- **`class Foo`** : 클래스 Foo에서 생성한 모든 객체 인스턴스들 집합
- **`Int -> Int`**: 정수형을 정수형으로 바꾸는(map) 함수들 집합

### **타입 시스템**

### **1. 정적Static 타입 시스템**

컴파일 시점에 타입이 정해지고, 타입에 적합한 값만 지정할 수 있다

```java
Int x = 2023
x = "code" //type error
String jk = 99 //type error
```

### **2. 동적Dynamic 타입 시스템**

컴파일 시점이 아니라 실행runtime 시점에 타입이 (바뀔수 있고) 정해진다.

```
x = 2023; //number
x = "code"; //string
x = { key: "jk" }; //object
jk = 99 + x; //error
코드복사코드복사
```

### **3. 강한Strong 타입 시스템**

강한 타입 시스템은 컴파일러가 타입 검사를 강하게 하기 때문에, 컴파일 과정마다 타입이 결정되야 한다. 타입 캐스팅 시점마다 변환할 타입을 명시해야 한다

```
Int x = 2023
Double y = 12.24 * x //compile error
코드복사코드복사
```

### **4. 약한Weak 타입 시스템**

약한 타입 시스템은 컴파일러가 타입 검사를 약하게 하고 런타임이 연산을 할 때 에러가 발생한다.

```
x = 2023
y = "12.3" * x === 24882.9
코드복사코드복사
```

### **5. 덕타입 Duck-Type 시스템**

동적 타입 시스템의 일종으로 **`Duck`** 타입으로 정적으로 생성해야만 하는 게 아니라,**`quack()`** 이라는 오리 고유의 행위를 구현하면 오리 타입으로 볼 수 있다는 duck-testing 의미로 부른다. 어떤 정적 타입이든, (언어에서 지원하는 방식으로) 다른 타입의 고유한 행위를 구현하면 된다는 의미로 사용

### **6. 언타입untype 시스템**

타입 구분이 없이 모든 데이터 구조가 하나의 타입으로 인지되는 시스템

### **메타 타입**

타입에 대한 타입, 타입 자체를 값으로 다룰 수 있는 타입자바에서 **`getClass()`**, JS에서 **`typeof(), instanceof()`**, 스위프트에서 **`type(of:), ObjectIdentifier`** 등으로 타입 비교 가능

> 자바와 스위프트는 위 함수 리턴 타입이 메타 타입임
>

---

## 체스게임

### 사전지식

[Chess.com - Play Chess Online - Free Games](https://www.chess.com/)

체스 게임 기본 규칙과 체스 말의 이동 경로

### 기능 요구 사항

- Board, Pawn, Bishop, Rook, Queen, Knight 클래스를 따로 구현
- 파일 추가, 기능 추가 시 gist 커밋
- 입력 → 검증 → 처리/계산 → 형식 → 출력 단계 구분
    - 각 단계를 담당하는 객체 혹은 모듈로 분리
- 프로그램 시작하면 King을 제외한 흑/백 체스말 초기화
- 프로그램을 동작하는 동안, 반복해서 입력을 받는다.
- 움직이려는 말이 있는 위치와 이동하려는 위치를 차례 입력받아서 말을 이동한다.
    - 입력값은 말이 있는 위치 2자리 문자와 -> 화살표와 이동하려는 위치 2자리 문자를 입력받는다. 형식에 맞지 않으면 다시 입력받는다.예시) **`B2->B3`** : B2에 있던 Pawn을 B3로 이동한다.
- 만약 흑 또는 백 체스말이 상대편 말이 있던 곳으로 이동해서 잡는 경우는 현재 체스판 점수를 출력한다.
- 입력값이 **`?`**물음표로 시작하면 해당 위치에 있는 말이 움직일 수 있는 경우를 모두 출력한다.
    - 만약 같은 색의 말이 진행 방향에서 가로막고 있는 경우는 그 직전까지만 표시한다.예시) A1에 흑색 Rook가 있고, C1에 흑색 Bishop이 있는 경우 **`?A1`** : **`"A2,A3,A4,A5,A6,A7,A8,B1"`**예시) F1에 흑색 Bishop이 있고, E2와 G2에 흑색 Pawn이 있는 경우 **`?F1`** : **`"없음"`**
- 체스말을 이동하는 명령은 백색부터 시작해서, 흑과 백이 번갈아서 입력해야 한다. 입력할 때마다 체스판 체스말 현황을 출력한다.
- 기능 요구사항과 프로그래밍 요구사항을 분석하고, 각자 나름의 기준으로 설계를 하고 그림이나 문장으로 표현해서 readme 문서에 기록한다.

### 프로그래밍 요구사항

- Board는 8x8(가로 rank, 세로 file) 크기 체스판에 체스말(Piece) 존재 여부를 관리

![https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/1624846017229Screen%20Shot%202021-06-28%20at%2011.06.44%20AM.png](https://s3.ap-northeast-2.amazonaws.com/lucas-image.codesquad.kr/1624846017229Screen%20Shot%202021-06-28%20at%2011.06.44%20AM.png)

- Board는 현재 있는 말을 확인해서 흑과 백 점수를 출력
    - 색상별로 Pawn 1점, Bishop와 Knight 3점, Rook 5점, Queen은 9점으로 계산한다.
- Board는 모든 말의 위치를 간접적으로 알 수 있다
    - display() 1-rank부터 8-rank까지 rank 전체 리턴
- Board에서 return한 데이터 구조를 바탕으로 출력 형식을 담당하는 객체(혹은 모듈)에서 문자열 배열 바꾸고 체스판을 출력하도록 전달한다.
    - 흑색 Pawn는 ♟ U+265F, Knight는 ♞ U+265E, Bishop은 ♝ U+265D, Rook는 ♜ U+265C, Queen은 ♛ U+265B를 빈 곳은 "."을 표시한다.
    - 백색 Pawn는 ♙ U+2659, Knight는 ♘ U+2658, Bishop은 ♗ U+2657, Rook는 ♖ U+2656, Queen은 ♕ U+2655를 빈 곳은 "."을 표시한다.
    - 예를 들어 초기화 상태에 Rook, Knight, Bishop, Queen이 있는 경우 1-rank는 **"♜♞♝.♛♝♞♜"** 가 된다.
    - 아래 예상 출력 참고
- 특정 위치에 특정 말을 생성하는 initPiece(type, position) 함수를 구현한다.
    - 초기화할 때 1,2-rank는 흑색 체스말이, 7,8-rank는 백색 체스말이 위치한다.
    - 체스말 초기 위치가 아니면 생성하지 않는다.
    - 이미 해당 위치에 다른 말이 있으면 생성하지 않는다.
    - 체스말 종류별로 최대 개수보다 많이 생성할 수는 없다.
    - Pawn는 색상별로 8개. Knight, Bishop, Rook는 색상별로 2개, Queen는 색상별로 1개만 가능하다.
    - 생성하지 않는 경우는 exception 예외처리로 상위에서 어떤 예외상황인지 판단한다.
- 특정 위치에 특정 말을 생성하는 setPiece(type, position) 함수를 구현한다.
    - initPiece()와 다르게 체스말은 어느 위치에 놓아도 상관없다.
    - 이미 해당 위치에 다른 말이 있으면 생성하지 않는다.
    - 체스말 최대 개수도 고려하지 않는다.
- 특정 말을 옮길 때는 Board에서 제공하는 move(from, to) 함수를 사용한다.
    - 같은 색상의 말이 to 위치에 다른 말이 이미 있으면 옮길 수 없다.
    - 말을 옮길 수 있으면 true, 옮길 수 없으면 false를 리턴한다.
    - 만약, 다른 색상의 말이 to 위치에 있는 경우는 기존에 있던 말을 제거하고 이동한다.
    - 다른 색상의 말을 제거한 경우는 흑과 백 점수를 출력한다.

### **체스말 공통**

- 체스말은 위치값을 Position 타입으로 갖는다.
    - 꼭 Position 값을 다루기 위한 데이터 구조를 별도로 만든다.
    - Position은 file은 A부터 H까지, rank는 1부터 8까지 입력이 가능하다.
    - file과 rank 값은 enum으로 선언한다.
- 체스말은 흑Black 또는 백White 둘 중에 하나여야 한다.
    - 상태값으로 지정한다면 생성할 때 결정하고 변경할 수 없어야 한다.
    - 타입으로 구분한다면 다형성으로 동작하도록 한다.
- 체스말은 현재 위치 Position을 기준으로 이동할 수 있는 모든 위치를 리턴하는 possiblePositions() 함수를 제공한다.
    - 다른 말이 있는지 여부는 판단하지 않는다.

### **Pawn 타입 요구사항**

- 생성 위치는 흑색은 2-rank 또는 백색 7-rank에만 가능하다.
- 백색은 더 작은 rank로 움직일 수 있고, 흑색은 더 큰 rank로 움직일 수 있다.
- 체스 게임과 달리 처음에도 1칸만 움직일 수 있고, 다른 말을 잡을 때도 대각선이 아니라 직선으로 움직일 때 잡는다고 가정한다.
- Pawn이 상대편 Rank에 도착하면 같은 색 Queen으로 변신한다.
    - 흑색 Pawn이 2-rank에서 시작해서 8-rank에 도착할 경우
    - 백색 Pawn이 7-rank에서 시작해서 1-rank에 도착할 경우

### **Bishop 타입 요구사항**

- 생성 위치는 흑색은 C-1 과 F-1 에만 가능하고, 백색은 C-8 과 F-8 에만 가능하다.
- 모든 색상이 놓여진 칸을 기준으로 대각선으로만 움직일 수 있다.

### **Rook 타입 요구사항**

- 생성 위치는 흑색은 A-1 과 H-1 에만 가능하고, 백색은 A-8 과 H-8 에만 가능하다.
- 모든 색상이 놓여진 칸을 기준으로 좌-우 또는 위-아래 방향으로 움직일 수 있다.

### **Queen 타입 요구사항**

- 생성 위치는 흑색은 E-1에만 가능하고, 백색은 E-8 에만 가능하다.
- 모든 색상이 놓여진 칸을 기준으로 대각선이 좌-우, 위-아래 방향으로 움직일 수 있다.

### **Knight 타입 요구사항**

- 생성 위치는 흑색은 B-1 과 G-1 에만 가능하고, 백색은 B-8 과 G-8 에만 가능하다.
- 모든 색상이 놓여진 칸을 기준으로 전진1칸+대각선1칸으로만 움직일 수 있다.
- 체스 게임과 달리 전진하는 칸이 막혀있으면 움직일 수 없다.

### 예상결과 및 동작예시

입출력 형식이 중요한게 아니라 역할 분담 나누는게 더 중요. 문자열 배열을 그대로 출력하지 않고 데이터 구조를 전달해서 Board 외부에서 출력
# CS11

# 주문 이벤트

### 스레드

### 이벤트 처리

### 비동기

### 콜백 함수

### 클로저

### ****CompletableFuture****

**[ 기존 Future ]**

java5에 추가되었다. 비동기 작업에 대한 결과값을 반환받을 수 있다.

**[ 문제점? ]**

- 외부에서 완료시킬 수 없고, GET의 타임아웃 설정으로만 완료 가능
- 블로킹 코드(get)를 통해서만 이후의 결과를 처리할 수 있음
- 여러 Future 조합 불가 ex) 회원 정보를 가져오고, 알림 발송 등
- 여러 작업을 조합하거나 예외처리할 수 없다

Future은 외부에서 작업을 완료시킬 수 없고 작업완료는 오직 get 호출 시에 타임 아웃으로만 가능하다. 또한 비동기 작업의 응답에 추가 작업을 하려면 Get을 호출해야하는데, Get은 블로킹 호출이므로 좋지 않다. 예외가 발생한 경우에 이를 위한 예외 처리도 불가능하다. 그래서 java8에서 CompletableFuture가 등장했다.

**[CompletableFuture 클래스]**

[CompletableFuture](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html)는 기존의 Future를 기반으로 외부에서 완료시킬 수 있어서 CompletableFuture라는 이름을 갖게 되었다. Future 외에도 [CompletionStage](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletionStage.html)
 인터페이스도 구현하고 있는데, CompletionStage는 작업들을 중첩시키거나 완료 후 콜백을 위해 추가되었다. 예를 들어 Future에서는 불가능했던 "몇 초 이내에 응답이 안 오면 기본값을 반환한다." 와 같은 작업이 가능해진 것이다. 즉, Future의 진화된 형태로써 외부에서 작업을 완료시킬 수 있을 뿐만 아니라 콜백 등록 및 Future 조합 등이 가능하다는 것이다

- 비동기 작업 실행
- 작업 콜백
- 작업 조합
- 예외 처리

- 쓰레드 풀
    - 병렬 작업 처리가 많아지면 스레드 개수가 증가되고, 그에 따른 스레드 생성과 스케줄링으로 인해 CPU가 바빠져 메모리 사용량이 늘어난다. 병렬 작업의 폭증으로 인한 스레드의 폭증을 막으려면 스페드 풀을 사용해야 한다.
    - 스레드 풀은 작업 처리에 사용되는 스레드를 제한된 갯수만큼 정해 놓고 작업 큐에 들어오는 작업들을 하나씩 스레드가 맡아 처리한다
    - 작업 처리가 끝난 스레드는 다시 작업 큐에서 새로운 작업을 가져와 처리한다. 따라서 작업 처리 요청이 폭증해도 작업 큐 라는 곳에 작업이 대기하다가 여유가 있는 스레드가 그것을 처리하므로 스레드의 전체 개수는 일정하며 어플리케이션의 성능도 저하되지 않는다.
- 콜백 등록

---

여러 프로그램들이 단일 스레드에서도 이벤트 단위의 병럴 처리 구조로 처리

### 기능요구사항

- 비동기로 동작하도록
- 비동기 함수 중심으로 구현
- 주문부터 제작 완료까지 이벤트 흐름을 그림으로 그려서, 학습 저장소에 함께 첨부

### 주문 이벤트 요구사항

- 캐셔는 음료 주문을 연속해서 받을 수 있다
- 음료 주문을 받으면 주문대기큐에 추가
- 매니저는 큐를 1초마다 확인
    - 주문이 있으면 바리스타한테 전달
    - 바리스타가 보낸 완료 이벤트를 받으면 결과 출력
- 바리스타는 동시에 2개까지 음료를 만들 수 있다
    - 스레드 직접생성아님. 이벤트 방식으로 동작
    - 음료 만들기 시작, 끝마다 이벤트 발생
    - 이벤트가 발생할 때마다 음료 작업에 대한 로그 출력
- 캐셔,매니저,바리스타(인스턴스 1개)

### 프로그래밍 요구사항

- 자바는 CompletableFuture 활용
- 모든 음료수를 만들고 3초동안 주문이 없으면 프로그램 종료

---

이번 미션에 우선순위 큐를 사용했는데 입력에서 값을 넘겨줄때 에러가 발생했다
class Coffee cannot be cast to class java.lang.Comparable
라는 얘기였는데 정렬을 해주지 않아서 나는 오류였다
그래서 Coffee 클래스에서 오름차순 정렬을 했다
근데 문제는 3:2를 입력하고 1:3이나 2:3 등 123의 순서는 1,2,3으로 넣지않고 3,2,1로 넣었을 때
큐 값이 흐트러진다. 이건 다시 고쳐봐야겠다....